// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v3.21.12
// source: creds/accessbox/accessbox.proto

package accessbox

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AccessBox struct {
	state           protoimpl.MessageState       `protogen:"open.v1"`
	OwnerPublicKey  []byte                       `protobuf:"bytes,1,opt,name=ownerPublicKey,proto3" json:"ownerPublicKey,omitempty"`
	Gates           []*AccessBox_Gate            `protobuf:"bytes,2,rep,name=gates,proto3" json:"gates,omitempty"`
	ContainerPolicy []*AccessBox_ContainerPolicy `protobuf:"bytes,3,rep,name=containerPolicy,proto3" json:"containerPolicy,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AccessBox) Reset() {
	*x = AccessBox{}
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessBox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessBox) ProtoMessage() {}

func (x *AccessBox) ProtoReflect() protoreflect.Message {
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessBox.ProtoReflect.Descriptor instead.
func (*AccessBox) Descriptor() ([]byte, []int) {
	return file_creds_accessbox_accessbox_proto_rawDescGZIP(), []int{0}
}

func (x *AccessBox) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *AccessBox) GetGates() []*AccessBox_Gate {
	if x != nil {
		return x.Gates
	}
	return nil
}

func (x *AccessBox) GetContainerPolicy() []*AccessBox_ContainerPolicy {
	if x != nil {
		return x.ContainerPolicy
	}
	return nil
}

type Tokens struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AccessKey     []byte                 `protobuf:"bytes,1,opt,name=accessKey,proto3" json:"accessKey,omitempty"`
	BearerToken   []byte                 `protobuf:"bytes,2,opt,name=bearerToken,proto3" json:"bearerToken,omitempty"`
	SessionTokens [][]byte               `protobuf:"bytes,3,rep,name=sessionTokens,proto3" json:"sessionTokens,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Tokens) Reset() {
	*x = Tokens{}
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Tokens) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tokens) ProtoMessage() {}

func (x *Tokens) ProtoReflect() protoreflect.Message {
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tokens.ProtoReflect.Descriptor instead.
func (*Tokens) Descriptor() ([]byte, []int) {
	return file_creds_accessbox_accessbox_proto_rawDescGZIP(), []int{1}
}

func (x *Tokens) GetAccessKey() []byte {
	if x != nil {
		return x.AccessKey
	}
	return nil
}

func (x *Tokens) GetBearerToken() []byte {
	if x != nil {
		return x.BearerToken
	}
	return nil
}

func (x *Tokens) GetSessionTokens() [][]byte {
	if x != nil {
		return x.SessionTokens
	}
	return nil
}

type AccessBox_Gate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tokens        []byte                 `protobuf:"bytes,1,opt,name=tokens,proto3" json:"tokens,omitempty"`
	GatePublicKey []byte                 `protobuf:"bytes,2,opt,name=gatePublicKey,proto3" json:"gatePublicKey,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessBox_Gate) Reset() {
	*x = AccessBox_Gate{}
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessBox_Gate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessBox_Gate) ProtoMessage() {}

func (x *AccessBox_Gate) ProtoReflect() protoreflect.Message {
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessBox_Gate.ProtoReflect.Descriptor instead.
func (*AccessBox_Gate) Descriptor() ([]byte, []int) {
	return file_creds_accessbox_accessbox_proto_rawDescGZIP(), []int{0, 0}
}

func (x *AccessBox_Gate) GetTokens() []byte {
	if x != nil {
		return x.Tokens
	}
	return nil
}

func (x *AccessBox_Gate) GetGatePublicKey() []byte {
	if x != nil {
		return x.GatePublicKey
	}
	return nil
}

type AccessBox_ContainerPolicy struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	LocationConstraint string                 `protobuf:"bytes,1,opt,name=locationConstraint,proto3" json:"locationConstraint,omitempty"`
	Policy             []byte                 `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *AccessBox_ContainerPolicy) Reset() {
	*x = AccessBox_ContainerPolicy{}
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessBox_ContainerPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessBox_ContainerPolicy) ProtoMessage() {}

func (x *AccessBox_ContainerPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_creds_accessbox_accessbox_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessBox_ContainerPolicy.ProtoReflect.Descriptor instead.
func (*AccessBox_ContainerPolicy) Descriptor() ([]byte, []int) {
	return file_creds_accessbox_accessbox_proto_rawDescGZIP(), []int{0, 1}
}

func (x *AccessBox_ContainerPolicy) GetLocationConstraint() string {
	if x != nil {
		return x.LocationConstraint
	}
	return ""
}

func (x *AccessBox_ContainerPolicy) GetPolicy() []byte {
	if x != nil {
		return x.Policy
	}
	return nil
}

var File_creds_accessbox_accessbox_proto protoreflect.FileDescriptor

const file_creds_accessbox_accessbox_proto_rawDesc = "" +
	"\n" +
	"\x1fcreds/accessbox/accessbox.proto\x12\taccessbox\"\xd5\x02\n" +
	"\tAccessBox\x12&\n" +
	"\x0eownerPublicKey\x18\x01 \x01(\fR\x0eownerPublicKey\x12/\n" +
	"\x05gates\x18\x02 \x03(\v2\x19.accessbox.AccessBox.GateR\x05gates\x12N\n" +
	"\x0fcontainerPolicy\x18\x03 \x03(\v2$.accessbox.AccessBox.ContainerPolicyR\x0fcontainerPolicy\x1aD\n" +
	"\x04Gate\x12\x16\n" +
	"\x06tokens\x18\x01 \x01(\fR\x06tokens\x12$\n" +
	"\rgatePublicKey\x18\x02 \x01(\fR\rgatePublicKey\x1aY\n" +
	"\x0fContainerPolicy\x12.\n" +
	"\x12locationConstraint\x18\x01 \x01(\tR\x12locationConstraint\x12\x16\n" +
	"\x06policy\x18\x02 \x01(\fR\x06policy\"n\n" +
	"\x06Tokens\x12\x1c\n" +
	"\taccessKey\x18\x01 \x01(\fR\taccessKey\x12 \n" +
	"\vbearerToken\x18\x02 \x01(\fR\vbearerToken\x12$\n" +
	"\rsessionTokens\x18\x03 \x03(\fR\rsessionTokensB;Z9github.com/nspcc-dev/neofs-s3-gw/creds/tokenbox;accessboxb\x06proto3"

var (
	file_creds_accessbox_accessbox_proto_rawDescOnce sync.Once
	file_creds_accessbox_accessbox_proto_rawDescData []byte
)

func file_creds_accessbox_accessbox_proto_rawDescGZIP() []byte {
	file_creds_accessbox_accessbox_proto_rawDescOnce.Do(func() {
		file_creds_accessbox_accessbox_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_creds_accessbox_accessbox_proto_rawDesc), len(file_creds_accessbox_accessbox_proto_rawDesc)))
	})
	return file_creds_accessbox_accessbox_proto_rawDescData
}

var file_creds_accessbox_accessbox_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_creds_accessbox_accessbox_proto_goTypes = []any{
	(*AccessBox)(nil),                 // 0: accessbox.AccessBox
	(*Tokens)(nil),                    // 1: accessbox.Tokens
	(*AccessBox_Gate)(nil),            // 2: accessbox.AccessBox.Gate
	(*AccessBox_ContainerPolicy)(nil), // 3: accessbox.AccessBox.ContainerPolicy
}
var file_creds_accessbox_accessbox_proto_depIdxs = []int32{
	2, // 0: accessbox.AccessBox.gates:type_name -> accessbox.AccessBox.Gate
	3, // 1: accessbox.AccessBox.containerPolicy:type_name -> accessbox.AccessBox.ContainerPolicy
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_creds_accessbox_accessbox_proto_init() }
func file_creds_accessbox_accessbox_proto_init() {
	if File_creds_accessbox_accessbox_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_creds_accessbox_accessbox_proto_rawDesc), len(file_creds_accessbox_accessbox_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_creds_accessbox_accessbox_proto_goTypes,
		DependencyIndexes: file_creds_accessbox_accessbox_proto_depIdxs,
		MessageInfos:      file_creds_accessbox_accessbox_proto_msgTypes,
	}.Build()
	File_creds_accessbox_accessbox_proto = out.File
	file_creds_accessbox_accessbox_proto_goTypes = nil
	file_creds_accessbox_accessbox_proto_depIdxs = nil
}
